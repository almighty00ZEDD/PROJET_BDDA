package miniSGBD;
import java.util.ArrayList;

public final class BufferManager {

	private static BufferManager INSTANCE;
	private static ArrayList<Frame> frames;
	private static ArrayList<byte []> buffers;
	
	private BufferManager() {
		frames = new ArrayList<Frame>(DBParams.frameCount);
		buffers = new ArrayList<byte []>(DBParams.frameCount);
	}
	
	public static BufferManager getInstance() {
		if(INSTANCE == null) {
			INSTANCE = new BufferManager();
		}
		return INSTANCE;
	}
	
	// TODO !!! vraiment à revoir !!! 
	public byte [] GetPage(PageId pi) {
		Frame f = new Frame(pi);
		
		//lecture disque
		if(!frames.contains(f)) {
			if(frames.size() < DBParams.frameCount) {
				frames.add(f);
				byte [] recuperation = new byte [DBParams.pageSize]; //sera libéré à la fin de la fonction donc pas de duplication!
				DiskManager.getInstance().ReadPage(pi, recuperation);
				buffers.add(recuperation);
				return recuperation;
			}
			
			//Remplacement LRU
			else {
				return null;
			}
		}
		
		//chargement depuis la ram (page déja chargée)
		else {
			int pos = frames.indexOf(f);
			frames.get(pos).increment_pin_count();
			return buffers.get(pos);
		}
		
	}
	
	void FreePage(PageId page,boolean valdirty) {
		
	}
	
	void FlushAll() {
		
	}
	public void Init() {
		System.out.println(frames.get(0));
	}
	
	public void Finish() {
		
	}
}
